# 数据结构与算法

![img](https://img-blog.csdn.net/20141221124905219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MjYxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



## 数据结构，算法概念

数据结构是指数据的组织方式，算法是指针对数据进行的增删改查类似操作的逻辑。数据算法与算法的选择都是要根据具体的数据量以及业务逻辑来选择的。

## 递归函数与循环

在不必须要使用递归函数时，尽量不要使用递归函数，会占用大量的栈空间，导致stack overflow。

## 多项式的表示

多项式f(x)=a0+a1*x+ a2*x^2+ ...+ an*x^n

写一个算法来计算该多项式的值。

### 方法一：从头至尾依次计算

### 方法二：从内向外计算，运用结合律

![1551945204496](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551945204496.png)

对程序运行而言，可以近似将加减操作视为瞬时操作，而乘除法则比较耗时。方法一每一个循环进行了i+1次乘法，加起来约为O(n^2),而方法为只进行一次乘法，加起来时间复杂度为O(n)。方法二明显优于方法一。

## 怎样去衡量算法的优劣

时间复杂度和空间复杂度，与数据量N的比例关系。

### 复杂度的渐近表示法

![1551946304671](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551946304671.png)

对程序员而言，如果我们已知一个算法的时间复杂度是0(N^2)时，应想办法将其复杂度降为0(NlogN).

## 最大连续子列和问题

给定一个int类型序列，要求找出这个序列里子列的最大和。

### 三层嵌套循环-垃圾算法

### 二层嵌套循环-垃圾算法

### 在线处理，最优算法-O(N)

```
public class MaxSubListSum {
  public int getMAxSubListSum(int[] arr, int length) {
    int currentMax = 0;
    int sum = 0;
    for (int i = 0; i < length; i++) {
      currentMax += arr[i];
      if (sum < currentMax) {
        sum = currentMax;
      } else if (currentMax < 0) {
        currentMax = 0;
      }
    }
    return sum;
  }
}
```

## 线性结构

### 一元多项式及其运算

![1551948225006](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551948225006.png)

考虑使用什么数据结构来存储进行呢？

1.很容易考虑使用数据来进行数据的存储，在数组的第i各元素存储ai的值。这样也可以很方便的进行来年各个多项式的加减操作，只需要对应项加减即可。但这种方式存在缺点，比如想要存储多项式

![1551948571508](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551948571508.png)

则需要一个包括2001个元素的数组，且大部分都是无用的，必然造成资源浪费。

为了弥补上述的缺点，可以考虑只存储非零项，依然考虑使用数组的话，可以将其数组中的元素定义为一个node

```
class Node{
    int index;
    float value;
}
```

使用上述node来存储，只需要一个含有两个元素的数组即可。

### 线性表List

线性表是指由同类元素构成的有序序列结构。

线性表可有两种实现方式：数组实现，链式实现。

#### 数组实现

数组实现线性表（内存单元连续）

​	增加、删除元素：受最初分配内存的大小影响，受需要插入的目的位置影响，效率不高。

​	查找元素： 可以根据index快速找到对应位置，很高效快速

链表实现线性表(内存单元不连续)

​	增加、删除元素：快速高效，只需要新建一个元素然后将其放在正确的位置即可，手查找效率影响

​	查找元素： 查找效率不高，需要遍历查找。

### 广义表

。。。

### 堆栈

进行数学计算

```
4+5*4/2
```

数学运算符具有优先级，而在获得运算符时只知道它前面的数字，所以需要将运算式子改为后缀表达式。

```
454*2/+
```

可以使用堆栈，将数字依次放入堆栈，当遇到一个操作符时，弹出两个数字，和运算符计算完后将数字填入堆栈，然后继续遍历。

#### 堆栈数组实现

使用指针top结合数组来实现，记录top指针的位置。增加元素时top++，弹出数组时top--，top以外的元素不允许数组访问即可，虽然元素并没有删除，内存并没有释放。

#### 堆栈链表实现

单向链表只能使用链头作为top，链尾无法找到上一个元素，所以不能进行删除操作。

### 队列

#### 数组实现 

front，rear两个指针，移动两个实现头和尾的增加和删除。

front向后挪，用于元素从头删除，rear向后移动，意味着添加元素。

数组在分配内存时是固定的，怎样才能最高效的使用这些内存呢？如果一直在头部进行删除而在尾部增加，会发现front，rear都在向后移动，等到rear到达数组最后一位时， 无法再添加元素，但是front指针之前空余空间，为了使用这些空间，可以使用循环队列来实现。

front==rear的时候有可能是两种情况：队列满了，或者队列为空。

解决方案：

 * 使用额外的flag用于判断最后一个操作是插入还是删除
 * 只使用n-1个数组长度（java中使用这种方式）

#### 链式实现

只能使用链表头做front，链表为作为rear，因为链表尾无法进行删除操作。

## 树结构

客观世界存在的层次结构。比如文件目录，国家行政机构划分。

层次管理能够达到较高的管理效率，主要就是插入，删除，查找。因此树结构也能带来较高的效率。

### 查找

​	静态查找，动态查找

#### 如何从数组中查找一个元素

在数组中进行查找时，循环条件有两个（1）是否相等（2）index是否越界。每一轮循环都会进行两次循环，效率较低，所以在数组arr[]中查找k的时候，可以使用建立哨兵的方式进行

```
int search(int[] arr, int length, int k){
    arr[0]=k;
    int index;
	for(index=lenght;index>=0;index--){}
	return index;
}

int index = search(...);
//如果index==0，不存在，
//如果index！=0，存在。
```

#### 哨兵的设置

哨兵让效率更高，总是返回值（0或非0），后续操作也符合逻辑。

#### 二分查找

时间复杂度为O(logN),条件是按顺序存放在数组里面。

### 树的定义

* N个节点构成的有限元集合。
* 子树不相交
* 树是保证节点连接的最小单位
* 节点子树个数为该节点的度

#### 树的表示

* 可以使用数组来表示树吗？
  * 不行，针对普通的树，每个节点的个数不一致，所以数组没办法表明父节点子节点的关系
* 可以使用链表表示树吗？
  * 不行，因为每个节点度不一致，那么为节点构造类的时候，这个类兼容度最大的节点，导致资源浪费，且无法有效表示其连接状态。

##### 儿子兄弟表示法

儿子兄弟表示法可以将普通的树装换为二叉树。

![1551965067854](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551965067854.png)

一般的树可以通过儿子兄弟表示法将其转换为二叉树，所以研究二叉树对所有树很有意义。

#### 二叉树

完美二叉树，完全二叉树。

##### 完全二叉树使用数组表示

![1551965621120](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551965621120.png)

一般的二叉树可以视情况而定，将空位补全，然后使用数组存储。会造成空间浪费。

##### 完全二叉树链表存储

##### 二叉树遍历（链表实现）

* 前序
* 中序
* 后序
* 层序

遍历树的方式：

* 递归遍历
* 堆栈遍历

层序遍历

1 将根节点放入序列

2 弹出一个节点，同时将该节点的左右节点放入序列

3 继续弹出节点

### 二叉树的查找

#### 二叉搜索树





