# 数据结构与算法

![img](https://img-blog.csdn.net/20141221124905219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjE1MjYxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



## 数据结构，算法概念

数据结构是指数据的组织方式，算法是指针对数据进行的增删改查类似操作的逻辑。数据算法与算法的选择都是要根据具体的数据量以及业务逻辑来选择的。

## 递归函数与循环

在不必须要使用递归函数时，尽量不要使用递归函数，会占用大量的栈空间，导致stack overflow。

## 多项式的表示

多项式f(x)=a0+a1*x+ a2*x^2+ ...+ an*x^n

写一个算法来计算该多项式的值。

### 方法一：从头至尾依次计算

### 方法二：从内向外计算，运用结合律

![1551945204496](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551945204496.png)

对程序运行而言，可以近似将加减操作视为瞬时操作，而乘除法则比较耗时。方法一每一个循环进行了i+1次乘法，加起来约为O(n^2),而方法为只进行一次乘法，加起来时间复杂度为O(n)。方法二明显优于方法一。

## 怎样去衡量算法的优劣

时间复杂度和空间复杂度，与数据量N的比例关系。

### 复杂度的渐近表示法

![1551946304671](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551946304671.png)

对程序员而言，如果我们已知一个算法的时间复杂度是0(N^2)时，应想办法将其复杂度降为0(NlogN).

## 最大连续子列和问题

给定一个int类型序列，要求找出这个序列里子列的最大和。

### 三层嵌套循环-垃圾算法

### 二层嵌套循环-垃圾算法

### 在线处理，最优算法-O(N)

```
public class MaxSubListSum {
  public int getMAxSubListSum(int[] arr, int length) {
    int currentMax = 0;
    int sum = 0;
    for (int i = 0; i < length; i++) {
      currentMax += arr[i];
      if (sum < currentMax) {
        sum = currentMax;
      } else if (currentMax < 0) {
        currentMax = 0;
      }
    }
    return sum;
  }
}
```

## 线性结构

### 一元多项式及其运算

![1551948225006](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551948225006.png)

考虑使用什么数据结构来存储进行呢？

1.很容易考虑使用数据来进行数据的存储，在数组的第i各元素存储ai的值。这样也可以很方便的进行来年各个多项式的加减操作，只需要对应项加减即可。但这种方式存在缺点，比如想要存储多项式

![1551948571508](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551948571508.png)

则需要一个包括2001个元素的数组，且大部分都是无用的，必然造成资源浪费。

为了弥补上述的缺点，可以考虑只存储非零项，依然考虑使用数组的话，可以将其数组中的元素定义为一个node

```
class Node{
    int index;
    float value;
}
```

使用上述node来存储，只需要一个含有两个元素的数组即可。

### 线性表List

线性表是指由同类元素构成的有序序列结构。

线性表可有两种实现方式：数组实现，链式实现。

#### 数组实现

数组实现线性表（内存单元连续）

​	增加、删除元素：受最初分配内存的大小影响，受需要插入的目的位置影响，效率不高。

​	查找元素： 可以根据index快速找到对应位置，很高效快速

链表实现线性表(内存单元不连续)

​	增加、删除元素：快速高效，只需要新建一个元素然后将其放在正确的位置即可，手查找效率影响

​	查找元素： 查找效率不高，需要遍历查找。

### 广义表

。。。

### 堆栈

进行数学计算

```
4+5*4/2
```

数学运算符具有优先级，而在获得运算符时只知道它前面的数字，所以需要将运算式子改为后缀表达式。

```
454*2/+
```

可以使用堆栈，将数字依次放入堆栈，当遇到一个操作符时，弹出两个数字，和运算符计算完后将数字填入堆栈，然后继续遍历。

#### 堆栈数组实现

使用指针top结合数组来实现，记录top指针的位置。增加元素时top++，弹出数组时top--，top以外的元素不允许数组访问即可，虽然元素并没有删除，内存并没有释放。

#### 堆栈链表实现

单向链表只能使用链头作为top，链尾无法找到上一个元素，所以不能进行删除操作。

### 队列

#### 数组实现 

front，rear两个指针，移动两个实现头和尾的增加和删除。

front向后挪，用于元素从头删除，rear向后移动，意味着添加元素。

数组在分配内存时是固定的，怎样才能最高效的使用这些内存呢？如果一直在头部进行删除而在尾部增加，会发现front，rear都在向后移动，等到rear到达数组最后一位时， 无法再添加元素，但是front指针之前空余空间，为了使用这些空间，可以使用循环队列来实现。

front==rear的时候有可能是两种情况：队列满了，或者队列为空。

解决方案：

 * 使用额外的flag用于判断最后一个操作是插入还是删除
 * 只使用n-1个数组长度（java中使用这种方式）

#### 链式实现

只能使用链表头做front，链表为作为rear，因为链表尾无法进行删除操作。

## 树结构

客观世界存在的层次结构。比如文件目录，国家行政机构划分。

层次管理能够达到较高的管理效率，主要就是插入，删除，查找。因此树结构也能带来较高的效率。

### 查找

​	静态查找，动态查找

#### 如何从数组中查找一个元素

在数组中进行查找时，循环条件有两个（1）是否相等（2）index是否越界。每一轮循环都会进行两次循环，效率较低，所以在数组arr[]中查找k的时候，可以使用建立哨兵的方式进行

```
int search(int[] arr, int length, int k){
    arr[0]=k;
    int index;
	for(index=lenght;index>=0;index--){}
	return index;
}

int index = search(...);
//如果index==0，不存在，
//如果index！=0，存在。
```

#### 哨兵的设置

哨兵让效率更高，总是返回值（0或非0），后续操作也符合逻辑。

#### 二分查找

时间复杂度为O(logN),条件是按顺序存放在数组里面。

### 树的定义

* N个节点构成的有限元集合。
* 子树不相交
* 树是保证节点连接的最小单位
* 节点子树个数为该节点的度

#### 树的表示

* 可以使用数组来表示树吗？
  * 不行，针对普通的树，每个节点的个数不一致，所以数组没办法表明父节点子节点的关系
* 可以使用链表表示树吗？
  * 不行，因为每个节点度不一致，那么为节点构造类的时候，这个类兼容度最大的节点，导致资源浪费，且无法有效表示其连接状态。

##### 儿子兄弟表示法

儿子兄弟表示法可以将普通的树装换为二叉树。

![1551965067854](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551965067854.png)

一般的树可以通过儿子兄弟表示法将其转换为二叉树，所以研究二叉树对所有树很有意义。

#### 二叉树

完美二叉树，完全二叉树。

##### 完全二叉树使用数组表示

![1551965621120](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1551965621120.png)

一般的二叉树可以视情况而定，将空位补全，然后使用数组存储。会造成空间浪费。

##### 完全二叉树链表存储

##### 二叉树遍历（链表实现）

* 前序
* 中序
* 后序
* 层序

遍历树的方式：

* 递归遍历
* 堆栈遍历

层序遍历

1 将根节点放入序列

2 弹出一个节点，同时将该节点的左右节点放入序列

3 继续弹出节点

### 二叉树的查找

#### [二叉搜索树](https://blog.csdn.net/u012152619/article/details/42059325)

二叉搜索树可以使用数组来实现，但是最好还是使用链表来实现。

插入：插入时主要是要在程序中记录好准备插入位置的位置信息

搜索：使用二分查找法来进行查找

删除：删除可以分为三种情况来分开处理：

* 待删除节点没有子节点：将指向该节点的父节点对应指针置空即可
* 待删除节点有一个子节点：将指向该节点的父节点对应指针指向其唯一子节点
* 待删除节点包括两个子节点：
  * 从待删除节点的左子树中寻找一个最大的，将其值覆盖待删除接待，其父节点指向它的指针置空
  * 从待删除节点的右子树中寻找一个最小的，将其值覆盖待删除接待，其父节点指向它的指针置空

> 注： 删除操作是很繁琐的一步操作，但其实我们真的需要删除吗？其实不用，比如在树的node中加入一个flag，用于表示该node是否有效，在其删除后置为false，则就可以避免少出操作。

### 霍夫曼树以及霍夫曼编码

在进行传统编码时，每个字符的编码位数通常是固定的，有其总元素个数决定，比如我们班上有37个学生，则如果需要对其进行二进制编码的话，最少需要6位，因为32< 37<64。但其实还有另外一种编码方式，根据这些元素中的使用频率来进行编码调节，可以节省内存空间，即霍夫曼编码。

> 对使用频率高的字母用较少的位数来存储，而对使用频率低的字母用较多的位数来存储**，会大大提升存储效率

霍夫曼树是**最优二叉树**。树的**带权路径长度**规定为所有叶子结点的带权路径长度之和，带权路径长度最短的树，即为最优二叉树。在最优二叉树中，权值较大的结点离根较近。

霍夫曼树的构造方法是从所有元素中找出权值最小的两个元素将其构建一棵树，该树的根为两者权值之和，然后将这个和的权值在与原来的剩下的元素进行比较，依次迭代最终构建完整二叉树。

![1552058449289](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1552058449289.png)

其底层实现可借助有序队列来实现，每次拿出两个头结点，合成后再放进去，再次取出两个头结点。

### 红黑树

二叉树在进行数据插入时，因为其元素的无序性，有可能导致整体的树极度不平衡，从而导致树的高度加大，增加增加删除的时间复杂度，最坏的情况是将一个有序的数组进行插入，最后出来会是一个链表……

为了不使树变的如此糟糕，就必须保证输的相对平衡，红黑树就是设计出来为了保证输的平衡的。

#### 红黑规则

当插入（或者删除）一个节点时，必须遵循一定的规则，它们被称为红黑规则。如果遵循这些规则，树就是平衡的

* 每一个节点不是黑色就是红色

* 根总是黑色的

* 如果节点是红色的，则它的子节点必须是黑色的，反之则不一定成立

* 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点

  > 
  >
  > 待续……
  >
  > 

## 八大排序算法及其应用场景

以下介绍的排序算法都是基础的排序算法，存在即合理，他们各有优缺点，各自有不同的应用场景。

![1552059619618](C:\Users\shaungc\AppData\Roaming\Typora\typora-user-images\1552059619618.png)

### 冒泡排序

两层循环交换，每一次会将一个最大或最小的元素放在正确的位置，等值时不交换，因此是稳定排序。

```java
import java.util.Arrays;

public class BubbleSort {
  public void bubbleSort(int[] arr, int length) {
    for (int i = 0; i < length - 1; i++) {
      for (int j = 0; j < length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          int temp = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = temp;
        }
      }
    }
    System.out.println(Arrays.toString(arr));
  }
}
```

### 选择排序

每次从序列中找出一个最大或最小的，直接将其放在正确位置



### 插入排序

### 归并排序

### 快速排序

### 希尔排序

### 堆排序

### 基数排序